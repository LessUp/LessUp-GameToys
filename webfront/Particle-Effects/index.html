<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>粒子爆炸特效 · 烟花与能量轨迹</title>
  <style>
    :root {
      --bg: #07060d;
      --text: #f4f6ff;
      --muted: #a1a8bf;
      --panel: rgba(14, 12, 22, 0.82);
      --accent: #f97316;
      --accent-2: #a855f7;
      --border: rgba(168, 85, 247, 0.22);
      --radius: 18px;
      --shadow: 0 20px 50px rgba(2, 0, 10, 0.7);
    }

    * { box-sizing: border-box; }

    html, body {
      margin: 0;
      min-height: 100vh;
      font: 14px/1.5 "SF Pro Display", system-ui, -apple-system, "PingFang SC", "Microsoft YaHei", sans-serif;
      background: radial-gradient(circle at 20% 20%, rgba(168, 85, 247, 0.16), transparent 60%),
                  radial-gradient(circle at 85% 75%, rgba(249, 115, 22, 0.18), transparent 55%),
                  #07060d;
      color: var(--text);
      padding: 32px clamp(12px, 6vw, 36px);
      display: flex;
      justify-content: center;
    }

    .layout {
      width: min(1100px, 100%);
      display: grid;
      gap: 24px;
    }

    header {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    h1 {
      margin: 0;
      font-size: clamp(26px, 4vw, 34px);
      font-weight: 800;
      letter-spacing: -0.02em;
      background: linear-gradient(135deg, var(--accent), var(--accent-2));
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .subtitle {
      color: var(--muted);
      max-width: 680px;
    }

    .panel {
      background: var(--panel);
      border-radius: var(--radius);
      border: 1px solid rgba(148, 163, 184, 0.18);
      box-shadow: var(--shadow);
      padding: 18px;
      backdrop-filter: blur(12px);
    }

    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 16px;
    }

    .control {
      display: grid;
      gap: 6px;
    }

    .control label {
      font-size: 13px;
      color: var(--muted);
      font-weight: 600;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    input[type="range"] { accent-color: var(--accent); }
    select {
      width: 100%;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(168, 85, 247, 0.3);
      background: rgba(10, 9, 18, 0.85);
      color: var(--text);
      font-weight: 600;
      outline: none;
    }

    .buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-top: 18px;
    }

    button {
      appearance: none;
      border: 1px solid rgba(168, 85, 247, 0.28);
      background: linear-gradient(135deg, rgba(168, 85, 247, 0.5), rgba(249, 115, 22, 0.45));
      color: var(--text);
      font-weight: 600;
      padding: 8px 16px;
      border-radius: 12px;
      cursor: pointer;
      transition: transform 0.15s ease, border-color 0.2s ease;
    }

    button:hover { transform: translateY(-1px); border-color: rgba(249, 115, 22, 0.7); }
    button:active { transform: translateY(0); }
    button.secondary { background: linear-gradient(135deg, rgba(14, 165, 233, 0.35), rgba(59, 130, 246, 0.3)); }

    .stats {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      color: var(--muted);
      margin-top: 14px;
      font-size: 12px;
    }

    .chip {
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(168, 85, 247, 0.24);
      background: rgba(6, 5, 12, 0.72);
      letter-spacing: 0.2px;
    }

    .stage {
      position: relative;
      border-radius: var(--radius);
      border: 1px solid rgba(168, 85, 247, 0.25);
      overflow: hidden;
      min-height: 420px;
      height: min(70vh, 620px);
      background: radial-gradient(circle at 50% 90%, rgba(249,115,22,0.18), rgba(20,16,36,0.9) 40%, rgba(4,4,12,0.98) 90%);
      box-shadow: inset 0 0 0 1px rgba(2,0,12,0.85);
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    .hint {
      color: var(--muted);
      font-size: 12px;
      margin-top: 8px;
      text-align: right;
    }
  </style>
</head>
<body>
  <div class="layout">
    <header>
      <h1>粒子爆炸特效</h1>
      <p class="subtitle">点击或自动触发烟花、能量脉冲与尾迹轨迹。多种色彩主题和粒子行为，可用于创意交互展示。</p>
    </header>

    <div class="panel">
      <div class="controls">
        <div class="control">
          <label>自动间隔 (秒) <span id="labelInterval">1.8</span></label>
          <input id="interval" type="range" min="0.5" max="4" step="0.1" value="1.8" />
        </div>
        <div class="control">
          <label>粒子数量 <span id="labelCount">180</span></label>
          <input id="count" type="range" min="60" max="400" step="10" value="180" />
        </div>
        <div class="control">
          <label>尾迹长度 <span id="labelTrail">24</span></label>
          <input id="trail" type="range" min="6" max="32" step="1" value="24" />
        </div>
        <div class="control">
          <label>重力强度 <span id="labelGravity">260</span></label>
          <input id="gravity" type="range" min="-200" max="400" step="10" value="260" />
        </div>
        <div class="control">
          <label>主题</label>
          <select id="theme">
            <option value="aurora">极光</option>
            <option value="ember">余烬</option>
            <option value="ocean">深海</option>
            <option value="cyber">赛博</option>
          </select>
        </div>
        <div class="control">
          <label>爆炸类型</label>
          <select id="mode">
            <option value="firework">烟花</option>
            <option value="pulse">能量脉冲</option>
            <option value="ring">冲击环</option>
            <option value="sparkle">火花雨</option>
          </select>
        </div>
      </div>

      <div class="buttons">
        <button id="toggle">暂停自动</button>
        <button id="trigger" class="secondary">立即爆炸</button>
        <button id="clear">清除残留</button>
      </div>

      <div class="stats">
        <span class="chip">粒子数：<strong id="labelParticles">0</strong></span>
        <span class="chip">FPS：<strong id="labelFPS">0</strong></span>
        <span class="chip">平均寿命：<strong id="labelLife">0</strong>s</span>
      </div>
      <div class="hint">点击画布任意位置创建烟花 · 长按生成持续喷射 · 双指缩放控制全局缩放。</div>
    </div>

    <div class="stage">
      <canvas id="canvas"></canvas>
    </div>
  </div>

  <script>
    "use strict";
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    let width, height, dpr;

    function resize() {
      dpr = Math.max(1, window.devicePixelRatio || 1);
      const rect = canvas.getBoundingClientRect();
      width = Math.floor(rect.width);
      height = Math.floor(rect.height);
      canvas.width = width * dpr;
      canvas.height = height * dpr;
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.scale(dpr, dpr);
    }
    resize();
    window.addEventListener("resize", resize);

    const params = {
      interval: 1.8,
      count: 180,
      trail: 24,
      gravity: 260,
      theme: "aurora",
      mode: "firework",
      auto: true,
      zoom: 1,
    };

    const controls = {
      interval: document.getElementById("interval"),
      count: document.getElementById("count"),
      trail: document.getElementById("trail"),
      gravity: document.getElementById("gravity"),
      theme: document.getElementById("theme"),
      mode: document.getElementById("mode"),
      toggle: document.getElementById("toggle"),
      trigger: document.getElementById("trigger"),
      clear: document.getElementById("clear"),
    };

    const labels = {
      interval: document.getElementById("labelInterval"),
      count: document.getElementById("labelCount"),
      trail: document.getElementById("labelTrail"),
      gravity: document.getElementById("labelGravity"),
      particles: document.getElementById("labelParticles"),
      fps: document.getElementById("labelFPS"),
      life: document.getElementById("labelLife"),
    };

    function updateLabels() {
      labels.interval.textContent = params.interval.toFixed(1);
      labels.count.textContent = params.count;
      labels.trail.textContent = params.trail;
      labels.gravity.textContent = params.gravity.toFixed(0);
    }
    updateLabels();

    Object.entries({
      interval: (v) => params.interval = parseFloat(v),
      count: (v) => params.count = parseInt(v, 10),
      trail: (v) => params.trail = parseInt(v, 10),
      gravity: (v) => params.gravity = parseFloat(v),
      theme: (v) => params.theme = v,
      mode: (v) => params.mode = v,
    }).forEach(([key, fn]) => {
      controls[key].addEventListener("input", (e) => {
        fn(e.target.value);
        updateLabels();
      });
    });

    controls.toggle.addEventListener("click", () => {
      params.auto = !params.auto;
      controls.toggle.textContent = params.auto ? "暂停自动" : "恢复自动";
      if (params.auto) {
        scheduleNext();
      } else {
        clearTimeout(scheduleNext.timer);
        scheduleNext.timer = null;
      }
    });

    controls.trigger.addEventListener("click", () => {
      explode(width / 2, height * 0.4);
    });

    controls.clear.addEventListener("click", () => {
      particles.length = 0;
      bursts.length = 0;
    });

    const themes = {
      aurora: ["#22d3ee", "#38bdf8", "#a855f7", "#f472b6"],
      ember: ["#f97316", "#fb7185", "#facc15", "#ef4444"],
      ocean: ["#22d3ee", "#0ea5e9", "#2563eb", "#1d4ed8"],
      cyber: ["#22d3ee", "#14b8a6", "#f0abfc", "#a855f7"],
    };

    const particles = [];
    const bursts = [];

    class Particle {
      constructor(x, y, vx, vy, life, color, trailLength, size) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.life = life;
        this.maxLife = life;
        this.color = color;
        this.trail = [];
        this.trailLength = trailLength;
        this.size = size;
      }
      update(dt) {
        this.trail.push({ x: this.x, y: this.y });
        if (this.trail.length > this.trailLength) {
          this.trail.splice(0, this.trail.length - this.trailLength);
        }
        this.vy += params.gravity * dt * 0.5;
        this.vx *= 0.995;
        this.vy *= 0.995;
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        this.life -= dt;
      }
      draw(ctx) {
        const t = Math.max(0, this.life) / this.maxLife;
        const alpha = Math.max(0, Math.min(1, t * 1.2));
        const size = this.size * (0.6 + 0.8 * (1 - t));
        ctx.beginPath();
        const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, size);
        gradient.addColorStop(0, `${this.color}ff`);
        gradient.addColorStop(1, `${this.color}00`);
        ctx.fillStyle = gradient.replace(/#/g, "#");
        ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
        ctx.fill();

        ctx.beginPath();
        for (let i = 0; i < this.trail.length - 1; i++) {
          const p = this.trail[i];
          const q = this.trail[i + 1];
          const trailAlpha = (i / this.trail.length) ** 1.6 * 0.6;
          ctx.strokeStyle = hexToRgba(this.color, trailAlpha);
          ctx.lineWidth = 1.2;
          ctx.moveTo(p.x, p.y);
          ctx.lineTo(q.x, q.y);
        }
        ctx.stroke();
      }
    }

    class Burst {
      constructor(x, y, radius, color) {
        this.x = x;
        this.y = y;
        this.radius = radius;
        this.color = color;
        this.life = 0.7;
        this.maxLife = 0.7;
      }
      update(dt) {
        this.life -= dt;
        this.radius += dt * 240;
      }
      draw(ctx) {
        const t = Math.max(0, this.life) / this.maxLife;
        ctx.beginPath();
        ctx.lineWidth = 2 + 20 * (1 - t);
        ctx.strokeStyle = hexToRgba(this.color, t * 0.6);
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.stroke();
      }
    }

    function explode(x, y) {
      const palette = themes[params.theme];
      const color = palette[Math.floor(Math.random() * palette.length)];
      const count = params.count;
      const mode = params.mode;
      const baseLife = 1.6 + Math.random() * 0.8;
      const trailLength = params.trail;
      for (let i = 0; i < count; i++) {
        let angle = Math.random() * Math.PI * 2;
        let speed = 160 + Math.random() * 260;
        if (mode === "pulse") {
          angle = (Math.floor(Math.random() * 6) / 6) * Math.PI * 2 + (Math.random() - 0.5) * 0.4;
          speed = 220 + Math.random() * 180;
        } else if (mode === "ring") {
          angle = (i / count) * Math.PI * 2;
          speed = 260;
        } else if (mode === "sparkle") {
          angle = Math.random() * Math.PI * 2;
          speed = 100 + Math.random() * 100;
        }
        const size = 2.5 + Math.random() * 2.5;
        particles.push(new Particle(
          x,
          y,
          Math.cos(angle) * speed,
          Math.sin(angle) * speed,
          baseLife * (0.7 + Math.random() * 0.6),
          color,
          trailLength,
          size
        ));
      }
      bursts.push(new Burst(x, y, 20, color));
    }

    function scheduleNext() {
      if (!params.auto) return;
      clearTimeout(scheduleNext.timer);
      scheduleNext.timer = setTimeout(() => {
        explode(Math.random() * width * 0.8 + width * 0.1, height * (0.25 + Math.random() * 0.35));
        scheduleNext();
      }, params.interval * 1000);
    }
    scheduleNext();

    let isPressing = false;
    let pressTimer = 0;

    canvas.addEventListener("mousedown", (e) => {
      isPressing = true;
      const { x, y } = getCursor(e);
      explode(x, y);
    });
    canvas.addEventListener("mousemove", (e) => {
      if (!isPressing) return;
      pressTimer += 1;
      if (pressTimer % 4 === 0) {
        const { x, y } = getCursor(e);
        explode(x, y);
      }
    });
    window.addEventListener("mouseup", () => {
      isPressing = false;
      pressTimer = 0;
    });

    canvas.addEventListener("touchstart", (e) => {
      isPressing = true;
      const { x, y } = getCursor(e.touches[0]);
      explode(x, y);
      e.preventDefault();
    }, { passive: false });
    canvas.addEventListener("touchmove", (e) => {
      if (!isPressing) return;
      pressTimer += 1;
      if (pressTimer % 3 === 0) {
        const { x, y } = getCursor(e.touches[0]);
        explode(x, y);
      }
      e.preventDefault();
    }, { passive: false });
    window.addEventListener("touchend", () => {
      isPressing = false;
      pressTimer = 0;
    });

    canvas.addEventListener("wheel", (e) => {
      e.preventDefault();
      const s = Math.exp(-e.deltaY * 0.001);
      params.zoom = Math.max(0.6, Math.min(1.6, params.zoom * s));
    }, { passive: false });

    function getCursor(evt) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: (evt.clientX ?? evt.pageX) - rect.left,
        y: (evt.clientY ?? evt.pageY) - rect.top,
      };
    }

    function hexToRgba(hex, alpha) {
      const c = hex.replace('#', '');
      const bigint = parseInt(c, 16);
      const r = (bigint >> 16) & 255;
      const g = (bigint >> 8) & 255;
      const b = bigint & 255;
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    let lastTime = performance.now();
    let fpsTimer = 0;
    let frames = 0;

    function loop(time) {
      const dt = Math.min(0.033, (time - lastTime) / 1000 || 0.016);
      lastTime = time;

      ctx.clearRect(0, 0, width, height);
      ctx.save();
      ctx.translate(width / 2, height / 2);
      ctx.scale(params.zoom, params.zoom);
      ctx.translate(-width / 2, -height / 2);

      ctx.globalCompositeOperation = "lighter";

      let lifeSum = 0;
      const aliveParticles = [];
      for (const p of particles) {
        p.update(dt);
        if (p.life > 0 && p.y < height + 60) {
          aliveParticles.push(p);
          lifeSum += p.life;
          p.draw(ctx);
        }
      }
      particles.length = 0;
      particles.push(...aliveParticles);

      const activeBursts = [];
      for (const b of bursts) {
        b.update(dt);
        if (b.life > 0) {
          activeBursts.push(b);
          b.draw(ctx);
        }
      }
      bursts.length = 0;
      bursts.push(...activeBursts);

      ctx.restore();

      labels.particles.textContent = particles.length;
      labels.life.textContent = (lifeSum / Math.max(1, particles.length)).toFixed(2);

      frames++;
      fpsTimer += dt;
      if (fpsTimer >= 0.5) {
        labels.fps.textContent = Math.round(frames / fpsTimer);
        fpsTimer = 0;
        frames = 0;
      }

      requestAnimationFrame(loop);
    }

    requestAnimationFrame(loop);
  </script>
</body>
</html>
